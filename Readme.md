A resource is an entity that can be identified, named, addressed, or handled on the web.


A resource that exists only within another resource can be better represented as a sub-resource instead of a top-level resource in the URL. This makes the relationship clear for the developers using the API.

POST /repos/:owner/:repo/issues Create an issue. GET /repos/:owner/:repo/issues/:number Retrieve an issue. GET /repos/:owner/:repo/issues List all issues. PATCH /repos/:owner


 Render an action as part of a field of a resource. 
PATCH /repos/saurabhsahni/Hacks HOST api.github.com Content-Type: application/json Authorization: token OAUTH-TOKEN { "archived": true } 


Treat an action like a sub resource. 
PUT /repos/:owner/:repo/issues/:number/lock locks an issue.

action verb in the API URL. GET /search/code?q=:query: finds files in GitHub matching the given query.

Remote Procedure Call (RPC) is one of the simplest API paradigms, in which a client executes a block of code on another server.

High performance protocols that are available for RPC-style APIs, including Apache Thrift and gRPC.


GraphQL is a query language for APIs that has gained significant traction recently.
you do not need different HTTP verbs to describe the operation. Instead, you indicate in the JSON body whether you’re performing a query or a mutation



server needs to do additional processing to parse complex queries and verify parameters. Optimizing performance of GraphQL queries can be difficult, too. 

					To share data about events in real time, there are three common mechanisms: WebHooks, WebSockets, and HTTP Streaming.
					
					WebHooks
					A WebHook is just a URL that accepts an HTTP POST (or GET, PUT,
					or DELETE). An API provider implementing WebHooks will simply
					POST a message to the configured URL when something happens.
					Unlike with request–response APIs, with WebHooks, you can
					receive updates in real time. 
					
					Failures and retries
					Security
					Firewalls 
					Applications running behind firewalls can access APIs over HTTP, but they are unable to receive inbound traffic.
					Noise 
					Typically, each WebHook call represents one single event. When there are thousands of events happening in a short time that need to be sent via a single WebHook, it can be noisy
					
					
					WebSockets 
					WebSocket is a protocol used to establish a two-way streaming com‐ munication channel over a single Transport Control Protocol (TCP) connection. Although the protocol is generally used between a web client (e.g., a browser) and a server, it’s sometimes used for serverto-server communication, as well.
					
					on mobile devices or in regions where connectivity can be spotty. Clients are supposed to keep the connection alive. If the connection dies, the client needs to reinitiate it. 
					There are also issues related to scalability



KRB5_LOGIN_MODULE_NAME is the name of the Kerberos Login Module that should be used to obtain a Kerberos ticket for authentication.

A Login Module is a pluggable component in the Java Authentication and Authorization Service (JAAS) framework that performs the authentication of a user. In the case of Kerberos authentication, a Login Module is responsible for obtaining a Kerberos ticket and authenticating the user to the Kerberos Key Distribution Center (KDC).

The name of the Kerberos Login Module varies depending on the implementation and configuration of the Kerberos system. Commonly used names include "com.sun.security.auth.module.Krb5LoginModule" for the Oracle JDK, and "org.apache.hadoop.security.authentication.client.KerberosAuthenticator" for Hadoop.

You should consult the documentation of your Kerberos implementation or talk to your system administrator to determine the correct name of the Kerberos Login Module for your environment.

What is Livy? 
• A Service that manages long running Spark Contexts in your cluster 
• Open Source Apache Licensed 
• REST based interface & programmatic way using livyclient.   
• Lets you manage multiple Spark Contexts 
• Fine grained job submission 
• Client APIs in java, scala
• Retrieve job results over REST asynchronously or synchronously 

A keytab is a file used in Kerberos-based authentication to store the encrypted keys (also called long-term keys or service keys) for one or more users or service principals.

A keytab file is typically generated by a Kerberos administrator and distributed to users and service principals to enable them to authenticate without having to enter their password every time. The keytab file contains a copy of the encrypted key for each principal that it represents, along with other information such as the encryption types that the principal supports.

When a user or service principal needs to authenticate to a Kerberos realm, 
they present their credentials (usually a username and password) to the Kerberos Key Distribution Center (KDC), 
which generates a TGT (Ticket Granting Ticket).
The user or service principal can then use this TGT to obtain service tickets for the services they want to access.
When a service principal needs to authenticate to another service, 
it can use its keytab file to decrypt the service ticket and obtain the session key needed to establish a secure connection.

SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) is an authentication and 
security mechanism that uses the GSS-API (Generic Security Services Application Programming Interface) 
to negotiate and establish a security context between a client and a server.

GSS-API (Generic Security Services Application Programming Interface) is a standard interface for providing security services in a networked environment.

GSS-API is a generic API that provides a uniform interface to a range of security mechanisms, 
such as Kerberos, SSL/TLS, and Public Key Infrastructure (PKI). 
It is designed to be independent of the underlying security mechanism, 
allowing applications to use the same API for different security mechanisms without needing to modify the application code.



https://github.com/sumanentc/spark-livy/blob/master/src/main/java/ai/cuddle/livy/controler/LivyControler.java

https://github.com/lhfei/spark2-livy-demo/tree/master/src/main/resources

https://github.com/Nimtaa/LivyRest/blob/master/src/main/java/EmbeddedJettyMain.java

https://github.com/yaoqijun/livyDemo/tree/master/src/main

https://github.com/rajashashankmuppirala/LivySP/blob/main/src/main/java/com/shashank/livysp/client/LivyApi.java

https://github.com/kojish/hdinsight-spark-livy-client/blob/master/src/main/java/delsh/livy/LivyBatchClient.java



